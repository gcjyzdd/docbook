
\chapter{L1 Language}


\section{Introducing L1}

L1 is a minimal object oriented language. 
It has support for classes that contain fields and methods. 
There is no support for inheritence, abstract classes, overriding
or interfaces. 

\highlightdef{ $Prog = ClassId \rightarrow 
((FieldId \rightarrow type) 
\times (MethodId) \rightarrow meth))$ }

where 
\begin{flalign*}
meth &::= type\, m (type\, x) \{ x \} &\\
type &::= \text{bool} | m \\
e    &::= \text{if}\, e | \text{then}\, e\, \text{else}\, e | e.f | e.f := e 
               | e.m(e) | \text{new}\, c | x | \text{this} | \text{true} 
               | \text{false} | \text{null}
\end{flalign*}
with the identiﬁer conventions: $c \in ClassId$  for class identifiers,
$f \in FieldId$ for field identifiers and $m \in MethId$  for class 
identifiers.

\frmrule


\begin{example}
Here is an example program
\begin{lstlisting}
class Book {
	bool good;
	Person owner;
	bool readBy(Person x) {this.good := true}
}
class Person {
	Book like;
	Book meet (Person x) {this.like := x.like}
}
\end{lstlisting}

which has the following representation:


\[ \begin{array}{lllll}
P_{PB} & = & \text{Book}   & \mapsto & ((\text{good} \mapsto \text{bool}, 
                                   \text{owner} \mapsto \text{Person}), \\
       &   &               &         &  (\text{readBy} \mapsto \text{bool readBy(Person x)}
                                    \{ \text{this.good} := \text{true} \})), \\
       &   & \text{Person} & \mapsto & ((\text{like} \mapsto \text{Book}), \\
       &   &               &         &  (\text{meet} \mapsto \text{Book meet(Person x)}
                                    \{ \text{this.like} := \text{x.like} \}))	 \\
\end{array}\] 


\end{example}



\begin{example}
For the following program, find the representation in L1.

\begin{lstlisting}
class B {
	D m (E x) { true }
	C f
}
\end{lstlisting}
\end{example}

\frmrule

\[ \begin{array}{lllll}
P_B & = & \text{B}   & \mapsto & ((\text{f} \mapsto \text{C}), \\ 
    &   &            &         &  (\text{m} \mapsto \text{D m (E x)}
                                    \{ \text{true} \})) \\
\end{array}\] 

\frmrule

For program $P$, and identiﬁers $c$, $f$, $m$, we define 
a \textit{field lookup function} and a \textit{method lookup functions}.

\highlightdef{The \textbf{Field Lookup Function} 
$\mathcal{F}(\text{P},\text{c},\text{f}) 
= \text{P}(\text{c}) \downarrow_{1} (\text{f})$ \\
The \textbf{Method Lookup Function} 
$\mathcal{M}(\text{P},\text{c},\text{m}) 
= \text{P}(\text{c}) \downarrow_{2} (\text{m})$}

We also define the \textit{field set function} as 
$\mathcal{Fs}(\text{P},\text{c}) = \{ f\, |\, 
\mathcal{F}(\text{P},\text{c}, \text{f})\, \text{is defined} \}$
and the \textit{method set function} as
$\mathcal{Ms}(\text{P},\text{c}) = \{ m\, |\, 
\mathcal{M}(\text{P},\text{c}, \text{m})\, \text{is defined} \}$
If you give the field set function a program and class, it gives 
you the fields inside that class. If you give the method set 
function a program and a class, it outputs the methods inside the class. 

\section{Stack Frames and Heaps}

We now begin defining our runtime environment for our language. 
Most object oriented language have the notion of \textit{objects}, 
\textit{references}, \textit{stack frames} and a \text{heap}. 
We will give a model for all of these.

First we define an \textit{address} as a greek 
iota symbol subscripted with a natural number. 
For example, the first address is $\iota_0$, second address is $\iota_1$, and so on.
We therefore define the set all possible addresses, the \textit{address set}, as follows.

\highlightdef{\textbf{Address Set}: $addr = \{ \iota_i\, |\, i \in \{0,1,2,...\} \}$ }

Under this scheme, we can work with a \textit{countable infinite} 
number of memory addresses. 
But we will see soon that when we define operational semantics
we will involve a \textit{finite} a number of computation 
steps limiting the computation to using a finite number of addresses. 
So this model doesn't limit the applicability to real machines.

Next we define a \textit{value} to be either true, false, null, \textit{or 
an address} (in the same way addresses were a previously defined). 
So the set of all possible values, 
the \textit{value set}, can be defined as follows.

\highlightdef{\textbf{Value Set}: $val = \{ \text{true, false, null} \} \cup addr $}

A field can only have values that are taken from this value set. 
In fact, this coindices exactly with how we define an \textit{object}. 
An object can be seen as an instance 
of a class where we assign values to the fields of the objects. 
The values assigned have to be from the value set.

\highlightdef{\textbf{Objects}: $object = ClassId \times (FieldId \rightarrow val)$}

Recall that we said a value is either true, false, null, or 
an address. Well, a value that is an address is called a
 \textit{pointer} and say that the value points to the contents of memory.
In our model, \textit{pointers only point to addresses on heap}. 
Furthermore, the \textit{heap can only contain objects}.

In other words, a pointer cannot point to other pointers nor can they point to the primitive language values: true. false, null. Pointers are implicit – there are 
no pointers to pointers. To formalise this, we define our memory, the stack 
frame $\phi$ and heap $\chi$.

\highlightdef{\textbf{Heap}: $heap = addr \rightarrow object$}

The heap is a function that maps address to objects. 
This definition tells us that the heap can only store objects. 
This is definition is also how we deference pointers. When we 
dereference a pointer, the result is an object. This tells us that 
pointers can only point to objects.

Finally we have a stack frame.
\highlightdef{\textbf{Stack Frame}: $stack frame = addr \times val$ }
The stack frame is a tuple. The first component gives an address for the this
pointer in the current execution context. We give an object on the heap for this 
to point to. The second component of the tuple gives a value for x in the 
current execution context. Recall that right now, our methods always have exactly
one parameter called x. The second component of the stack frame gives a value to this x. 

\frmrule

\begin{example}
Below shows how we an example of a stack frame $\phi_0$ and heap $\chi_0$ 
for some execution context of $P_{BP}$. 


Below shows how we might visualise the stack frame and heap.

\end{example}

\frmrule

\begin{example}
Below shows a visualising of the stack frame and heap for 
some execution context of $P_{BP}$.
Write out formally the heap $\chi_9$ and frame $\phi_9$ 
which correspond to the following diagram:

\end{example}


\frmrule



\section{Updating Execution Contexts}

To describe an execution context update, we use the notation 
$A[s \mapsto t]$ which says informally \textit{take A, and update
$s$ to $t$}. Here $A$ is can be anything that makes up our execution context 
(like the heap) and $s$ is a particular stateful element of $A$ that is to be 
updated to the new element, $t$. This notation was used in 
\textit{Models of Computation} when we defined the operation semantics of the 
while language.

In L1 we are interesting in updating two things, (i) fields inside objects and 
(ii) the heap. Before we do this, recall that we defined an object as a 
function with signature $object = ClassId \times (FieldId \rightarrow val)$ 
and we defined the heap as a function with signature
$heap = addr \rightarrow object$. With these signatures in mind lets see how 
define updating.

\begin{itemize}   
\renewcommand{\labelitemi}{$\Box$}
\item \textbf{Updating Heap}
Given object $\chi$, we define $\chi[\iota \mapsto o]$ as a new, updated heap.
This says informally, \textit{take the heap $\chi$ and update the 
object at address $\iota$ to have object $o$}.

Firstly we have: $\chi[\iota \mapsto o](\iota) = o$. 
This tells us that new heap has the object $o$ at address $\iota$.
We also require, $\chi[\iota \mapsto o](\iota') = \chi(\iota')$ if $\iota' \neq \iota$. 
This says that the address that are not $\iota$ must stay the same.
The update only updates on field at a time. We want to change just $\iota$ and leave 
the other addresses alone.
\item \textbf{Updating Fields} 
Given object $o$, we define $o[f \mapsto v]$ as a new, updated object.
This says informally, \textit{take the object $o$ and update the 
value of its field $f$ to have a new value $v$}.

First the update must satisfy: $o[f \mapsto v] \downarrow_1 = o \downarrow_1$. 
This is a requirement that the new object has the same class id as the old one.
Next the update must change the field: $o[f \mapsto v] \downarrow_2 (f) = v$.
The field $f$ of the new object must have value $v$. 
Finally we require, $o[f \mapsto v] \downarrow_2 (f') = f'$ if $f' \neq f$. 
This says that the fields that are not $f$ must stay the same.
The update only updates on field at a time.
\end{itemize}

\highlightdef{\textbf{Updating}:
$o[f \mapsto v]$ describes \textit{field update} and
$\chi[z \mapsto v]$ describes \textit{heap update}}


Let's see some examples of how we can use these two definitions 
to update a given execution context.

\frmrule

% Slide 19 typo, update express has extra left bracket. 
% Diagram has \chi_9 but should read \chi_1

\begin{example}
Modify the diagram below, so that it describes the 
update: $\chi_1 = \chi_0[\iota 
\mapsto (\chi_0(\iota_3)[\text{good} \mapsto \text{true}])]$

\begin{figure}[h]
\begin{tikzpicture}[
  title/.style={},
  object/.style={rectangle split, rectangle split draw splits=false,
  draw, text width=2cm}
]

  \node[rectangle split, rectangle split horizontal,
  rectangle split parts=2, rectangle split draw splits=false, draw, 
  text width=1cm, anchor=center, text centered] 
  (stackframe){ this \nodepart{two} x};

  \node[object,rectangle split parts=3, below=0.5cm of stackframe] 
  (book){ \nodepart{one} :Book \nodepart{two} good:
    \nodepart{three} owner: false};

  \node[object,rectangle split parts=2, right=1cm of book] 
  (person1) {\nodepart{one} :Person \nodepart{two} like: null};

  \node[object, rectangle split parts=2, right=1cm of person1] 
  (person2) { \nodepart{one} :Person \nodepart{two} like:};

  % draw lines on first nodepart splits for the objects
  \draw(book.one split west) -- (book.one split east);
  \draw(person1.one split west) -- (person1.one split east);
  \draw(person2.one split west) -- (person2.one split east);

  % draw lines connecting stack frame and objects
  % this to book, x to person2, book to person1, person2 to person2
  \path[draw,>=triangle 45, ->] (stackframe.one south) -- ++(0,0.1) 
      -- ++(0,-0.4) -| (person2.north);
  \path[draw,>=triangle 45, ->] (stackframe.two east) -- ++(-0.2,0) 
      -| (person1.north);
  \path[draw,>=triangle 45, ->] (book.two east) -- ++(-0.2,0) 
      -- ++(0.6,0) -- ++(0,-1.2) -| (person2.south);
  \path[draw,>=triangle 45, ->] (person2.two east) -- ++(-0.2,0) 
      -- ++(0.6,0) -- ++(0, 0.2) -- (person2.east);
 

\end{tikzpicture}
\end{figure} 


\end{example}



Note: there is no operation which changes the class of an object.
Once an object has been created at runtime, it is has a \textit{static binding}
to the class. Also notice that there is no operation to change the stack frame.
In object-oriented languages, changing the values of this isn't usually done.
Also, changing directly the values of arguments isn't too common. 



\section{Interfence Rules Revision}



\inference[$It(1)$]{ s \\ d}{x}


\section{Operational Semantics}





\section{Type System}