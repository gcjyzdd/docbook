

\chapter{IO Devices}


\section{Introducing IO Devices}

\highlightdef{An \textbf{IO Device} is an 
\textit{an additional piece of hardware} added to memory and cpu}

Perhaps the most important IO device is the \textit{hard disk}. 
First we will look at device controllers which are arguably the heart of the
communication between cpu and devices. 

\section{Device Controllers}

Every io-device has, inside, a \textit{device controller}.  
The device controller is simply more hardware, but this hardware has a particular purpose. 
Device controllers are placed on an io device to give the cpu an interface for communicating
with the device. In other words, it’s the io-device’s way of making it open to be 
accessed or \textit{controlled} by the cpu. 

The processor communicates with this controller but is unaware of how the device 
operates externally.
In other to let the cpu communicate with the device, the io-device provides 
\textit{registers}. If the cpu wants to talk to the device, the cpu writes 
to registers inside the device controller. 

Hopefully if the device isn’t too busy, it will somehow know the cpu said something and read its
registers. If the device wants to talk to the cpu, the device writes to the register and the
device can only to hope the cpu will know the write is there and read it – if the cpu isn’t too busy. 
\highlightdef{A \textbf{Device Controller} is hardware inside an io device that contains
\textit{registers} in order to \textit{provide communication with the cpu}.}
Device controllers are also known as \textit{io-controllers}, 
\textit{io-adapters} or \textit{io-modules}. 

Although the registers inside a device controller provide a shared storage between cpu 
and the device, there is a difficulty in making one party aware that the other has said 
something. We will refer to this problem as the \textit{CPU-Device Scheduling Problem}. 
Later we will look at schemes that attempt solve this problem.

Very often the device controller is a very small part of the actual hardware device 
(like a small chip or block stuck on the back). 
Sometimes the device controller is the majority of the hardware device 
(like a network card).

\highlightdef{The \textbf{IO Address Space} is the \textit{processor's collection}
of all the \textit{device controller's registers}}

The device controller’s registers appear to the processor as normal memory locations. 
Hence the cpu can easily manipulate the device controller’s registers by simply 
using instructions such as mov, and, or, test. 
The operand be will an io-address-space memory address.

\section{Buses and Bridges}

\highlightdef{An \textbf{IO Bus} is a network of io devices.}
A computer usually has many io bus networks. However, there is a need for separatimh networks 
of io-devices because devices operate \textit{at different speeds}. 
Some examples of common standardised io-bus networks are \textit{PCI}, 
\textit{IDE}, \textit{SCSI}, \textit{USB}, \textit{ISA} and \textit{Firewire}. 
When an io-bus network of one type is connected to another type, we have require a \textit{bridge}. 
Every device will be connected to some io-bus network and will be able to indirectly communicate with the processor. 

The cpu can access one or more io devices through one or more networks.
There is one network that the cpu is inside. The cpu has direct access to all the io devices 
inside this network. This network is known as the \textit{local bus}. 

\highlightdef{The \textbf{Local Bus} is the \textit{io-bus} the cpu has 
\textit{direct access} to}
where \textit{direct} means that no bridges are involved in communication. 
Communication is done through on network only. 

\section{CPU-Device Scheduling Problem}

\begin{figure}[h]
\begin{tikzpicture} [
   every node/.style={node_sty, align=center},
   edge from parent/.style={edge_sty},
   edge from parent path={(\tikzparentnode.south) |- ($(\tikzparentnode.south)!0.5!(\tikzchildnode.north)$) -| (\tikzchildnode.north)},
   level 1/.style={sibling distance=2cm, level distance = 0.6cm},
   level 2/.style={sibling distance=3cm, level distance = 0.9cm}
]
   \node 
   (root) [text width=18em] {CPU-Device Scheduling Problem}
   child{
      node (sol) {Solutions}
      child {node (pio) {Programmed IO}}
      child {node(intio) [text width=6em] {Interrupt-driven IO}}
      child {node(intio) [text width=6em] {DMA IO}}
      child {node(intio) [text width=6em] {IO Coprocessor}}
   };
   
\end{tikzpicture}
\end{figure}

The operating system schedules io-requests in an attempt to maximise their throughput (based on the io- device’s characteristics).

Synchronous I/O read() or write() will block a user process until its completion 
OS overlaps synchronous I/O with another process 
Asynchronous I/O read() or write() will not block a user process 
user process can do other things before I/O completion 
I/O completion will notify the user proces

\begin{itemize}   
\renewcommand{\labelitemi}{$\Box$}
\item \textbf{Addition of Cosets.} This is defined as: $(+r)I$ add $(+s)I = (+(r+s))I$
\item \textbf{Multiplication of Cosets.}  This is defined as: $(+r)I$ times $(+s)I = (+(r\times s))I$
\end{itemize}

